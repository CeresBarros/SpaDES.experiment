% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/experiment2.R
\name{as.data.table.simLists}
\alias{as.data.table.simLists}
\title{Coerce elements of a simLists object to a data.table}
\usage{
\method{as.data.table}{simLists}(x, byRep = TRUE, vals,
  objectsFromSim = NULL, objectsFromOutputs = NULL, ...)
}
\arguments{
\item{x}{An R object.}

\item{byRep}{Should the \code{data.table} have a column labelled "rep", indicating replicate
number/label. Currently, only \code{TRUE} is accepted.}

\item{vals}{A character vector or list of object names to extract from each
\code{simList}, or a list of quoted expressions to calculate for each \code{simList},
or a mix of character and quoted expressions.}

\item{objectsFromSim}{Character vector of objects to extract from the simLists. If
omitted, it will extract all objects from each simList in order to calculate the
\code{vals}. This may have a computational cost.}

\item{objectsFromOutputs}{Character vector of objects to load from the
\code{outputs(sim)} prior to evaluating \code{vals}. If there already is an object
with that same name in the \code{simList}, then it will be overwritten with
the object loaded from \code{outputs(sim)}. If there are many objects with the
same name, specifically from several \code{saveTime} values in the \code{outputs(sim)},
these will all be loaded, one at a time, \code{vals} evaluated one at a time, and
all the unique values will be returned. A column, \code{saveTime}, will be
part of the returned value.}

\item{...}{Additional arguments. Currently unused.}
}
\description{
This is particularly useful to build plots using the \pkg{tidyverse}, e.g., \pkg{ggplot2}.
}
\details{
See examples.
}
\examples{
\dontrun{

  # Make 3 simLists -- set up scenarios
  endTime <- 5
  tmpdir <- file.path(tempdir(), "testing")
  tmpCache <- file.path(tempdir(), "testingCache")
  # Example of changing parameter values
  mySim1 <- simInit(
    times = list(start = 0.0, end = endTime, timeunit = "year"),
    params = list(
      .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
      # Turn off interactive plotting
      fireSpread = list(.plotInitialTime = NA, spreadprob = c(0.2), nFires = c(10)),
      caribouMovement = list(.plotInitialTime = NA),
      randomLandscapes = list(.plotInitialTime = NA, .useCache = "init")
    ),
    modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
    paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"),
                 outputPath = tmpdir,
                 cachePath = tmpCache),
    # Save final state of landscape and caribou
    outputs = data.frame(objectName = c(rep("landscape", endTime), "caribou", "caribou"),
                         saveTimes = c(seq_len(endTime), unique(c(ceiling(endTime/2),endTime))),
                         stringsAsFactors = FALSE)
  )

  mySim2 <- simInit(
    times = list(start = 0.0, end = endTime, timeunit = "year"),
    params = list(
      .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
      # Turn off interactive plotting
      fireSpread = list(.plotInitialTime = NA, spreadprob = c(0.2), nFires = c(20)),
      caribouMovement = list(.plotInitialTime = NA),
      randomLandscapes = list(.plotInitialTime = NA, .useCache = "init")
    ),
    modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
    paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"),
                 outputPath = tmpdir,
                 cachePath = tmpCache),
    # Save final state of landscape and caribou
    outputs = data.frame(objectName = c(rep("landscape", endTime), "caribou", "caribou"),
                         saveTimes = c(seq_len(endTime), unique(c(ceiling(endTime/2),endTime))),
                         stringsAsFactors = FALSE)
  )

  mySim3 <- simInit(
    times = list(start = 0.0, end = endTime, timeunit = "year"),
    params = list(
      .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
      # Turn off interactive plotting
      fireSpread = list(.plotInitialTime = NA, spreadprob = c(0.2), nFires = c(30)),
      caribouMovement = list(.plotInitialTime = NA),
      randomLandscapes = list(.plotInitialTime = NA, .useCache = "init")
    ),
    modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
    paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"),
                 outputPath = tmpdir,
                 cachePath = tmpCache),
    # Save final state of landscape and caribou
    outputs = data.frame(objectName = c(rep("landscape", endTime), "caribou", "caribou"),
                         saveTimes = c(seq_len(endTime), unique(c(ceiling(endTime/2),endTime))),
                         stringsAsFactors = FALSE)
  )

  # Run experiment -- can use parallelism, if desired. Default is plan("sequential"), meaning
  #   "normal" sequential, single threaded runs
  # library(future)
  # plan("multiprocess")
  sims <- experiment2(sim1 = mySim1, sim2 = mySim2, sim3 = mySim3,
                      replicates = 3, useCache = FALSE)

  ### If spades already run -- can manually add to a simLists object
  # simsManual <- new("simLists")
  # simsManual$sim1_rep1 <- sims$sim1_rep1

  # Convert to data.table so can do stuff with
  # Just pull out a variable from the simLists -- simplest case
  df1 <- as.data.table(sims, byRep = TRUE, vals = c("nPixelsBurned"))

  measure.cols <- grep("nPixelsBurned", names(df1), value = TRUE)
  df1Short <- data.table::melt(df1, measure.vars = measure.cols, variable.name = "year")
  df1Short[, year := as.numeric(gsub(".*V([[:digit:]])", "\\\\1", df1Short$year))]
  library(ggplot2)
  p<- ggplot(df1Short, aes(x=year, y=value, group=simList, color=simList)) +
    stat_summary(geom = "point", fun.y = mean) +
    stat_summary(geom = "line", fun.y = mean) +
    stat_summary(geom = "errorbar", fun.data = mean_se, width = 0.2)

  print(p)

  # A quoted function -- do not prefix objects with 'sim' -- next two lines are identical
  df1 <- as.data.table(sims, byRep = TRUE, vals = list(NCaribou = quote(length(caribou$x1))))
  df1 <- as.data.table(sims, byRep = TRUE, vals = list(NCaribou = "length(caribou$x1)"))

  p<- ggplot(df1, aes(x=simList, y=NCaribou, group=simList, color=simList)) +
    stat_summary(geom = "point", fun.y = mean) +
    stat_summary(geom = "errorbar", fun.data = mean_se, width = 0.2)
  print(p)

  # A much more complicated object to calculate -- an estimate of perimeter to area ratio of fires
  library(raster)
  perimToAreaRatioFn <- quote({
    landscape$Fires[landscape$Fires[]==0] <- NA;
    a <- boundaries(landscape$Fires, type = "inner");
    a[landscape$Fires[] > 0 & a[] == 1] <- landscape$Fires[landscape$Fires[] > 0 & a[] == 1];
    peri <- table(a[]);
    area <- table(landscape$Fires[]);
    keep <- match(names(area),names(peri));
    mean(peri[keep]/area)
  })

  df1 <- as.data.table(sims, byRep = TRUE,
                       vals = c(perimToArea = perimToAreaRatioFn,
                                meanFireSize = quote(mean(table(landscape$Fires[])[-1]))),
                       objectsFromOutputs = c("landscape")) # need to get landscape obj from disk
  if (interactive()) {
    # with an unevaluated string
    p <- ggplot(df1, aes(x=saveTime, y=perimToArea, group=simList, color=simList)) +
      stat_summary(geom = "point", fun.y = mean) +
      stat_summary(geom = "line", fun.y = mean) +
      stat_summary(geom = "errorbar", fun.data = mean_se, width = 0.2)
    print(p) # may have NAs, giving warning, if perimeter calculation couldn't be completed
  }


} # end /dontrun
}
