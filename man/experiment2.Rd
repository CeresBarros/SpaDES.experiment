% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/experiment2.R
\docType{methods}
\name{experiment2}
\alias{experiment2}
\alias{experiment2,simList-method}
\title{Run experiment, algorithm 2, using \code{\link[SpaDES.core]{spades}}}
\usage{
experiment2(..., replicates = 1, clearSimEnv = FALSE,
  createUniquePaths = c("outputPath"), useCache = FALSE,
  debug = getOption("spades.debug"), drive_auth_account)

\S4method{experiment2}{simList}(..., replicates = 1,
  clearSimEnv = FALSE, createUniquePaths = c("outputPath"),
  useCache = FALSE, debug = getOption("spades.debug"),
  drive_auth_account = NULL)
}
\arguments{
\item{...}{One or more \code{simList} objects}

\item{replicates}{The number of replicates to run of the same \code{simList}.
See details and examples.}

\item{clearSimEnv}{Logical. If TRUE, then the envir(sim) of each simList in the return list
is emptied. This is to reduce RAM load of large return object.
Default FALSE.}

\item{createUniquePaths}{A character vector of the \code{paths} passed to \code{simInit},
indicating which should create a new, unique path, as a sub-path to the original
\code{paths} of \code{simInit}. Default, and currently only option, is \code{"outputPath"}}

\item{useCache}{Logical. Passed to \code{spades}. This will be passed with the \code{simList}
name and replicate number, allowing each replicate and each \code{simList} to be
seen as a non-cached call to \code{spades}. This will, however, may prevent \code{spades}
calls from running a second time during second call to the same
\code{experiment2} function.}

\item{debug}{Optional logical flag or character vector indicating what to print to
console at each event. See details.
Default is to use the value in \code{getOption("spades.debug")}.}
}
\value{
Invisibly returns a \code{simLists} object. This class
extends the \code{environment} class and
contains \code{simList} objects.
}
\description{
Given one or more \code{simList} objects, run a series of \code{spades} calls
in a structured, organized way. Methods are available to deal with outputs,
such as \code{as.data.table.simLists} which can pull out simple to complex
values from every resulting \code{simList} or object saved by \code{outputs}
in every \code{simList} run. This uses \code{future} internally, allowing
for various backends and parallelism.0
}
\details{
This function, because of its class formalism, allows for methods to be used. For example,
\code{\link{as.data.table.simLists}} allows user to pull out specific objects (in
the \code{simList} objects or on disk saved in \code{outputPath(sim)}).

The \code{outputPath} is changed so that every simulation puts outputs in a
sub-directory
of the original \code{outputPath} of each \code{simList}.
}
\note{
A \code{simLists} object can be made manually, if, say, many manual \code{spades} calls
have already been run. See example, via \code{new("simLists")}
}
\examples{
\dontrun{

  # Make 3 simLists -- set up scenarios
  endTime <- 5
  tmpdir <- file.path(tempdir(), "testing")
  tmpCache <- file.path(tempdir(), "testingCache")
  # Example of changing parameter values
  mySim1 <- simInit(
    times = list(start = 0.0, end = endTime, timeunit = "year"),
    params = list(
      .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
      # Turn off interactive plotting
      fireSpread = list(.plotInitialTime = NA, spreadprob = c(0.2), nFires = c(10)),
      caribouMovement = list(.plotInitialTime = NA),
      randomLandscapes = list(.plotInitialTime = NA, .useCache = "init")
    ),
    modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
    paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"),
                 outputPath = tmpdir,
                 cachePath = tmpCache),
    # Save final state of landscape and caribou
    outputs = data.frame(objectName = c(rep("landscape", endTime), "caribou", "caribou"),
                         saveTimes = c(seq_len(endTime), unique(c(ceiling(endTime/2),endTime))),
                         stringsAsFactors = FALSE)
  )

  mySim2 <- simInit(
    times = list(start = 0.0, end = endTime, timeunit = "year"),
    params = list(
      .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
      # Turn off interactive plotting
      fireSpread = list(.plotInitialTime = NA, spreadprob = c(0.2), nFires = c(20)),
      caribouMovement = list(.plotInitialTime = NA),
      randomLandscapes = list(.plotInitialTime = NA, .useCache = "init")
    ),
    modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
    paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"),
                 outputPath = tmpdir,
                 cachePath = tmpCache),
    # Save final state of landscape and caribou
    outputs = data.frame(objectName = c(rep("landscape", endTime), "caribou", "caribou"),
                         saveTimes = c(seq_len(endTime), unique(c(ceiling(endTime/2),endTime))),
                         stringsAsFactors = FALSE)
  )

  mySim3 <- simInit(
    times = list(start = 0.0, end = endTime, timeunit = "year"),
    params = list(
      .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
      # Turn off interactive plotting
      fireSpread = list(.plotInitialTime = NA, spreadprob = c(0.2), nFires = c(30)),
      caribouMovement = list(.plotInitialTime = NA),
      randomLandscapes = list(.plotInitialTime = NA, .useCache = "init")
    ),
    modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
    paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"),
                 outputPath = tmpdir,
                 cachePath = tmpCache),
    # Save final state of landscape and caribou
    outputs = data.frame(objectName = c(rep("landscape", endTime), "caribou", "caribou"),
                         saveTimes = c(seq_len(endTime), unique(c(ceiling(endTime/2),endTime))),
                         stringsAsFactors = FALSE)
  )

  # Run experiment -- can use parallelism, if desired. Default is plan("sequential"), meaning
  #   "normal" sequential, single threaded runs
  # library(future)
  # plan("multiprocess")
  sims <- experiment2(sim1 = mySim1, sim2 = mySim2, sim3 = mySim3,
                      replicates = 3, useCache = FALSE)

  ### If spades already run -- can manually add to a simLists object
  # simsManual <- new("simLists")
  # simsManual$sim1_rep1 <- sims$sim1_rep1

  # Convert to data.table so can do stuff with
  # Just pull out a variable from the simLists -- simplest case
  df1 <- as.data.table(sims, byRep = TRUE, vals = c("nPixelsBurned"))

  measure.cols <- grep("nPixelsBurned", names(df1), value = TRUE)
  df1Short <- data.table::melt(df1, measure.vars = measure.cols, variable.name = "year")
  df1Short[, year := as.numeric(gsub(".*V([[:digit:]])", "\\\\1", df1Short$year))]
  library(ggplot2)
  p<- ggplot(df1Short, aes(x=year, y=value, group=simList, color=simList)) +
    stat_summary(geom = "point", fun.y = mean) +
    stat_summary(geom = "line", fun.y = mean) +
    stat_summary(geom = "errorbar", fun.data = mean_se, width = 0.2)

  print(p)

  # A quoted function -- do not prefix objects with 'sim' -- next two lines are identical
  df1 <- as.data.table(sims, byRep = TRUE, vals = list(NCaribou = quote(length(caribou$x1))))
  df1 <- as.data.table(sims, byRep = TRUE, vals = list(NCaribou = "length(caribou$x1)"))

  p<- ggplot(df1, aes(x=simList, y=NCaribou, group=simList, color=simList)) +
    stat_summary(geom = "point", fun.y = mean) +
    stat_summary(geom = "errorbar", fun.data = mean_se, width = 0.2)
  print(p)

  # A much more complicated object to calculate -- an estimate of perimeter to area ratio of fires
  library(raster)
  perimToAreaRatioFn <- quote({
    landscape$Fires[landscape$Fires[]==0] <- NA;
    a <- boundaries(landscape$Fires, type = "inner");
    a[landscape$Fires[] > 0 & a[] == 1] <- landscape$Fires[landscape$Fires[] > 0 & a[] == 1];
    peri <- table(a[]);
    area <- table(landscape$Fires[]);
    keep <- match(names(area),names(peri));
    mean(peri[keep]/area)
  })

  df1 <- as.data.table(sims, byRep = TRUE,
                       vals = c(perimToArea = perimToAreaRatioFn,
                                meanFireSize = quote(mean(table(landscape$Fires[])[-1]))),
                       objectsFromOutputs = c("landscape")) # need to get landscape obj from disk
  if (interactive()) {
    # with an unevaluated string
    p <- ggplot(df1, aes(x=saveTime, y=perimToArea, group=simList, color=simList)) +
      stat_summary(geom = "point", fun.y = mean) +
      stat_summary(geom = "line", fun.y = mean) +
      stat_summary(geom = "errorbar", fun.data = mean_se, width = 0.2)
    print(p) # may have NAs, giving warning, if perimeter calculation couldn't be completed
  }


} # end /dontrun
}
\seealso{
\code{\link{as.data.table.simLists}},
  \code{\link{simInit}}, \code{\link[SpaDES.core]{spades}}, \code{\link{experiment}}
}
\author{
Eliot McIntire
}
